<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isolation Forest 切割過程視覺化</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft JhengHei', 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
        }
        
        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .tutorial {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 5px solid #667eea;
        }
        
        .tutorial h3 {
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .tutorial ol {
            margin-left: 25px;
            line-height: 1.8;
        }
        
        .controls {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .control-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: transform 0.2s;
            font-weight: bold;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .canvas-wrapper {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 15px;
        }
        
        .canvas-wrapper h3 {
            color: #667eea;
            margin-bottom: 10px;
            text-align: center;
        }
        
        canvas {
            border: 2px solid #e0e7ff;
            border-radius: 8px;
            display: block;
            margin: 0 auto;
            cursor: crosshair;
        }
        
        @media (max-width: 1200px) {
            .canvas-container {
                grid-template-columns: 1fr;
            }
        }
        
        .info-panel {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .info-panel h3 {
            color: #667eea;
            margin-bottom: 15px;
        }
        
        .cut-info {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #667eea;
        }
        
        .cut-info.active {
            border-left-color: #e74c3c;
            background: #fff5f5;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .stat-label {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        
        .stat-value {
            color: #667eea;
            font-size: 1.5em;
            font-weight: bold;
        }
        
        .point-status {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .point-badge {
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: bold;
        }
        
        .point-badge.isolated {
            background: #e74c3c;
            color: white;
        }
        
        .point-badge.active {
            background: #3498db;
            color: white;
        }
        
        .highlight-box {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }
        
        .highlight-box strong {
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔪 Isolation Forest 切割過程視覺化</h1>
        <p class="subtitle">看看每一刀怎麼把異常點孤立出來！</p>
        
        <div class="tutorial">
            <h3>📚 使用說明</h3>
            <ol>
                <li><strong>點擊左側畫布</strong>新增資料點（建議 10-20 個點）</li>
                <li>或使用<strong>「生成範例資料」</strong>快速建立資料</li>
                <li>點擊<strong>「開始建立孤立樹」</strong>開始切割過程</li>
                <li>使用<strong>「下一刀」</strong>按鈕逐步觀看每次切割</li>
                <li>觀察<strong>右側視圖</strong>：看哪些點被孤立了（紅色）</li>
                <li><strong>異常點會更早被孤立</strong>（需要較少的切割次數）</li>
            </ol>
        </div>
        
        <div class="controls">
            <div class="control-row">
                <button onclick="generateSampleData()">🎲 生成範例資料</button>
                <button onclick="clearData()" class="btn-secondary">🗑️ 清空資料</button>
                <button onclick="startIsolation()" id="startBtn" class="btn-success">▶️ 開始建立孤立樹</button>
                <button onclick="nextCut()" id="nextBtn" disabled>➡️ 下一刀（切割）</button>
                <button onclick="autoPlay()" id="autoBtn" disabled>⏩ 自動播放</button>
                <button onclick="reset()" id="resetBtn" disabled class="btn-secondary">🔄 重新開始</button>
            </div>
        </div>
        
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <h3>📍 原始資料點分布</h3>
                <canvas id="originalCanvas" width="600" height="600"></canvas>
            </div>
            <div class="canvas-wrapper">
                <h3>🔪 切割過程視覺化</h3>
                <canvas id="cutCanvas" width="600" height="600"></canvas>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #3498db;"></div>
                <span>活躍點（尚未孤立）</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #e74c3c;"></div>
                <span>已孤立點</span>
            </div>
            <div class="legend-item">
                <div style="width: 20px; height: 3px; background: #2ecc71;"></div>
                <span>切割線</span>
            </div>
        </div>
        
        <div class="info-panel">
            <h3>📊 切割資訊</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">總資料點數</div>
                    <div class="stat-value" id="totalPoints">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">已切割次數</div>
                    <div class="stat-value" id="cutCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">已孤立點數</div>
                    <div class="stat-value" id="isolatedCount">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">剩餘活躍點數</div>
                    <div class="stat-value" id="activeCount">0</div>
                </div>
            </div>
            
            <div id="currentCutInfo" class="cut-info" style="margin-top: 20px; display: none;">
                <strong>當前切割：</strong>
                <div id="cutDetails"></div>
                <div class="point-status" id="pointStatus"></div>
            </div>
            
            <div class="highlight-box" style="margin-top: 15px;">
                <strong>💡 觀察重點：</strong>
                <div id="observation">點擊「開始建立孤立樹」開始觀察切割過程...</div>
            </div>
        </div>
    </div>

    <script>
        const originalCanvas = document.getElementById('originalCanvas');
        const cutCanvas = document.getElementById('cutCanvas');
        const originalCtx = originalCanvas.getContext('2d');
        const cutCtx = cutCanvas.getContext('2d');
        
        let dataPoints = [];
        let cuts = [];
        let currentCutIndex = 0;
        let isolatedPoints = new Set();
        let isPlaying = false;
        
        const CANVAS_SIZE = 600;
        const MARGIN = 50;
        const PLOT_SIZE = CANVAS_SIZE - 2 * MARGIN;
        const DATA_RANGE = 10;
        
        // 座標轉換
        function dataToCanvas(x, y) {
            const canvasX = MARGIN + (x / DATA_RANGE) * PLOT_SIZE;
            const canvasY = CANVAS_SIZE - MARGIN - (y / DATA_RANGE) * PLOT_SIZE;
            return [canvasX, canvasY];
        }
        
        function canvasToData(canvasX, canvasY) {
            const x = ((canvasX - MARGIN) / PLOT_SIZE) * DATA_RANGE;
            const y = ((CANVAS_SIZE - MARGIN - canvasY) / PLOT_SIZE) * DATA_RANGE;
            return [Math.max(0, Math.min(DATA_RANGE, x)), Math.max(0, Math.min(DATA_RANGE, y))];
        }
        
        // 繪製座標軸
        function drawAxes(ctx) {
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            
            // 網格線
            for (let i = 0; i <= 10; i++) {
                const pos = MARGIN + (i / 10) * PLOT_SIZE;
                ctx.beginPath();
                ctx.moveTo(pos, MARGIN);
                ctx.lineTo(pos, CANVAS_SIZE - MARGIN);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(MARGIN, pos);
                ctx.lineTo(CANVAS_SIZE - MARGIN, pos);
                ctx.stroke();
            }
            
            // 座標軸
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(MARGIN, CANVAS_SIZE - MARGIN);
            ctx.lineTo(CANVAS_SIZE - MARGIN, CANVAS_SIZE - MARGIN);
            ctx.lineTo(CANVAS_SIZE - MARGIN, MARGIN);
            ctx.stroke();
            
            // 標籤
            ctx.fillStyle = '#666';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('0', MARGIN, CANVAS_SIZE - MARGIN + 20);
            ctx.fillText('10', CANVAS_SIZE - MARGIN, CANVAS_SIZE - MARGIN + 20);
            ctx.textAlign = 'right';
            ctx.fillText('0', MARGIN - 10, CANVAS_SIZE - MARGIN + 5);
            ctx.fillText('10', MARGIN - 10, MARGIN + 5);
        }
        
        // 繪製點
        function drawPoints(ctx, points, isolatedSet = new Set(), highlightActive = false) {
            points.forEach((point, idx) => {
                const [x, y] = dataToCanvas(point[0], point[1]);
                const isIsolated = isolatedSet.has(idx);
                
                ctx.beginPath();
                ctx.arc(x, y, isIsolated ? 8 : 10, 0, 2 * Math.PI);
                
                if (isIsolated) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.fill();
                    // 畫 X
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x - 4, y - 4);
                    ctx.lineTo(x + 4, y + 4);
                    ctx.moveTo(x + 4, y - 4);
                    ctx.lineTo(x - 4, y + 4);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = highlightActive ? '#3498db' : '#3498db';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        }
        
        // 繪製切割線
        function drawCut(ctx, cut) {
            const { axis, value } = cut;
            ctx.strokeStyle = '#2ecc71';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            
            ctx.beginPath();
            if (axis === 'x') {
                const [x, _] = dataToCanvas(value, 0);
                ctx.moveTo(x, MARGIN);
                ctx.lineTo(x, CANVAS_SIZE - MARGIN);
            } else {
                const [_, y] = dataToCanvas(0, value);
                ctx.moveTo(MARGIN, y);
                ctx.lineTo(CANVAS_SIZE - MARGIN, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // 初始化畫布
        function initCanvas() {
            originalCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            cutCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            drawAxes(originalCtx);
            drawAxes(cutCtx);
            drawPoints(originalCtx, dataPoints);
            updateStats();
        }
        
        // 點擊新增點
        originalCanvas.addEventListener('click', (e) => {
            if (cuts.length > 0) return; // 已開始切割，不允許新增
            
            const rect = originalCanvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;
            const [x, y] = canvasToData(canvasX, canvasY);
            
            if (x >= 0 && x <= DATA_RANGE && y >= 0 && y <= DATA_RANGE) {
                dataPoints.push([x, y]);
                initCanvas();
            }
        });
        
        // 生成範例資料
        function generateSampleData() {
            dataPoints = [];
            
            // 正常點群 1
            for (let i = 0; i < 15; i++) {
                dataPoints.push([
                    2 + Math.random() * 2,
                    2 + Math.random() * 2
                ]);
            }
            
            // 正常點群 2
            for (let i = 0; i < 15; i++) {
                dataPoints.push([
                    6 + Math.random() * 2,
                    6 + Math.random() * 2
                ]);
            }
            
            // 異常點
            dataPoints.push([9, 1]);
            dataPoints.push([1, 9]);
            dataPoints.push([9, 9]);
            
            reset();
            initCanvas();
        }
        
        // 清空資料
        function clearData() {
            dataPoints = [];
            reset();
            initCanvas();
        }
        
        // 開始孤立過程
        function startIsolation() {
            if (dataPoints.length < 2) {
                alert('請至少新增 2 個資料點！');
                return;
            }
            
            cuts = [];
            currentCutIndex = 0;
            isolatedPoints.clear();
            
            // 生成切割序列
            generateCuts();
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('nextBtn').disabled = false;
            document.getElementById('autoBtn').disabled = false;
            document.getElementById('resetBtn').disabled = false;
            
            updateVisualization();
            updateObservation();
        }
        
        // 生成切割序列
        function generateCuts() {
            let activePoints = new Set(dataPoints.map((_, i) => i));
            
            while (activePoints.size > 0 && cuts.length < 50) {
                // 隨機選擇軸和切割值
                const axis = Math.random() > 0.5 ? 'x' : 'y';
                const axisIdx = axis === 'x' ? 0 : 1;
                
                // 從活躍點中找範圍
                const activePointsArray = Array.from(activePoints).map(i => dataPoints[i]);
                const values = activePointsArray.map(p => p[axisIdx]);
                const min = Math.min(...values);
                const max = Math.max(...values);
                const value = min + Math.random() * (max - min);
                
                cuts.push({ axis, value, activePoints: new Set(activePoints) });
                
                // 更新活躍點：選擇較少的一側繼續
                const left = Array.from(activePoints).filter(i => dataPoints[i][axisIdx] < value);
                const right = Array.from(activePoints).filter(i => dataPoints[i][axisIdx] >= value);
                
                if (left.length === 1) {
                    isolatedPoints.add(left[0]);
                    activePoints.delete(left[0]);
                } else if (right.length === 1) {
                    isolatedPoints.add(right[0]);
                    activePoints.delete(right[0]);
                } else if (left.length === 0 || right.length === 0) {
                    // 無效切割，所有點都在一側
                    cuts.pop();
                    continue;
                } else {
                    // 選擇較少的一側繼續
                    activePoints = new Set(left.length < right.length ? left : right);
                }
            }
        }
        
        // 下一刀
        function nextCut() {
            if (currentCutIndex >= cuts.length) {
                document.getElementById('nextBtn').disabled = true;
                document.getElementById('autoBtn').disabled = true;
                updateObservation('complete');
                return;
            }
            
            currentCutIndex++;
            updateVisualization();
            updateObservation();
            
            if (currentCutIndex >= cuts.length) {
                document.getElementById('nextBtn').disabled = true;
                document.getElementById('autoBtn').disabled = true;
            }
        }
        
        // 自動播放
        async function autoPlay() {
            if (isPlaying) return;
            isPlaying = true;
            document.getElementById('autoBtn').disabled = true;
            document.getElementById('nextBtn').disabled = true;
            
            while (currentCutIndex < cuts.length && isPlaying) {
                nextCut();
                await new Promise(resolve => setTimeout(resolve, 800));
            }
            
            isPlaying = false;
            document.getElementById('autoBtn').disabled = false;
            if (currentCutIndex < cuts.length) {
                document.getElementById('nextBtn').disabled = false;
            }
        }
        
        // 更新視覺化
        function updateVisualization() {
            cutCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            drawAxes(cutCtx);
            
            // 繪製所有切割線
            for (let i = 0; i < currentCutIndex; i++) {
                drawCut(cutCtx, cuts[i]);
            }
            
            // 計算當前已孤立的點
            const currentIsolated = new Set();
            for (let i = 0; i < currentCutIndex; i++) {
                const cut = cuts[i];
                const axisIdx = cut.axis === 'x' ? 0 : 1;
                
                Array.from(cut.activePoints).forEach(idx => {
                    const point = dataPoints[idx];
                    const left = Array.from(cut.activePoints).filter(i => 
                        dataPoints[i][axisIdx] < cut.value
                    );
                    const right = Array.from(cut.activePoints).filter(i => 
                        dataPoints[i][axisIdx] >= cut.value
                    );
                    
                    if ((left.length === 1 && left[0] === idx) || 
                        (right.length === 1 && right[0] === idx)) {
                        currentIsolated.add(idx);
                    }
                });
            }
            
            drawPoints(cutCtx, dataPoints, currentIsolated, true);
            updateStats(currentIsolated);
            updateCutInfo(currentIsolated);
        }
        
        // 更新統計
        function updateStats(isolatedSet = new Set()) {
            document.getElementById('totalPoints').textContent = dataPoints.length;
            document.getElementById('cutCount').textContent = currentCutIndex;
            document.getElementById('isolatedCount').textContent = isolatedSet.size;
            document.getElementById('activeCount').textContent = dataPoints.length - isolatedSet.size;
        }
        
        // 更新切割資訊
        function updateCutInfo(isolatedSet) {
            if (currentCutIndex === 0) {
                document.getElementById('currentCutInfo').style.display = 'none';
                return;
            }
            
            document.getElementById('currentCutInfo').style.display = 'block';
            const cut = cuts[currentCutIndex - 1];
            const axisName = cut.axis === 'x' ? 'X 軸' : 'Y 軸';
            
            document.getElementById('cutDetails').innerHTML = `
                <div style="margin-top: 10px;">
                    切割方向：<strong>${axisName}</strong> | 
                    切割位置：<strong>${cut.value.toFixed(2)}</strong>
                </div>
            `;
            
            // 顯示點的狀態
            const statusHtml = dataPoints.map((point, idx) => {
                if (isolatedSet.has(idx)) {
                    return `<span class="point-badge isolated">點 ${idx} 已孤立</span>`;
                } else {
                    return `<span class="point-badge active">點 ${idx} 活躍</span>`;
                }
            }).join('');
            
            document.getElementById('pointStatus').innerHTML = statusHtml;
        }
        
        // 更新觀察提示
        function updateObservation(status = 'progress') {
            const observationDiv = document.getElementById('observation');
            
            if (status === 'complete') {
                const pathLengths = dataPoints.map((_, idx) => {
                    for (let i = 0; i < cuts.length; i++) {
                        const cut = cuts[i];
                        const axisIdx = cut.axis === 'x' ? 0 : 1;
                        const left = Array.from(cut.activePoints).filter(j => 
                            dataPoints[j][axisIdx] < cut.value
                        );
                        const right = Array.from(cut.activePoints).filter(j => 
                            dataPoints[j][axisIdx] >= cut.value
                        );
                        
                        if ((left.length === 1 && left[0] === idx) || 
                            (right.length === 1 && right[0] === idx)) {
                            return i + 1;
                        }
                    }
                    return cuts.length;
                });
                
                const avgPath = pathLengths.reduce((a, b) => a + b, 0) / pathLengths.length;
                const minPath = Math.min(...pathLengths);
                const maxPath = Math.max(...pathLengths);
                
                observationDiv.innerHTML = `
                    <strong>切割完成！</strong><br>
                    • 最少切割次數：${minPath} 次（這些點最容易孤立 = 可能是異常點）<br>
                    • 最多切割次數：${maxPath} 次（這些點較難孤立 = 可能是正常點）<br>
                    • 平均切割次數：${avgPath.toFixed(1)} 次<br>
                    <br>
                    <strong>關鍵發現：</strong>需要較少切割次數就被孤立的點，更可能是異常點！
                `;
            } else if (currentCutIndex === 0) {
                observationDiv.innerHTML = `準備開始切割...注意觀察哪些點會先被孤立出來！`;
            } else {
                const isolatedList = [];
                const pathLengths = dataPoints.map((_, idx) => {
                    for (let i = 0; i < currentCutIndex; i++) {
                        const cut = cuts[i];
                        const axisIdx = cut.axis === 'x' ? 0 : 1;
                        const left = Array.from(cut.activePoints).filter(j => 
                            dataPoints[j][axisIdx] < cut.value
                        );
                        const right = Array.from(cut.activePoints).filter(j => 
                            dataPoints[j][axisIdx] >= cut.value
                        );
                        
                        if ((left.length === 1 && left[0] === idx) || 
                            (right.length === 1 && right[0] === idx)) {
                            isolatedList.push({ idx, cuts: i + 1 });
                            return i + 1;
                        }
                    }
                    return null;
                }).filter(x => x !== null);
                
                if (isolatedList.length > 0) {
                    const listHtml = isolatedList
                        .sort((a, b) => a.cuts - b.cuts)
                        .map(item => `點 ${item.idx}（${item.cuts} 刀）`)
                        .join('、');
                    observationDiv.innerHTML = `
                        已有 ${isolatedList.length} 個點被孤立：${listHtml}<br>
                        這些點被孤立得越早，越可能是異常點！
                    `;
                } else {
                    observationDiv.innerHTML = `已切割 ${currentCutIndex} 次，尚未有點被完全孤立...`;
                }
            }
        }
        
        // 重置
        function reset() {
            cuts = [];
            currentCutIndex = 0;
            isolatedPoints.clear();
            isPlaying = false;
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('nextBtn').disabled = true;
            document.getElementById('autoBtn').disabled = true;
            document.getElementById('resetBtn').disabled = true;
            document.getElementById('currentCutInfo').style.display = 'none';
            
            initCanvas();
            updateObservation();
        }
        
        // 初始化
        initCanvas();
        generateSampleData();
    </script>
</body>
</html>